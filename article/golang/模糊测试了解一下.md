## 前言

> 大家好，我是`asong`。好久没写文了，都不知道该怎么开头了，今天想与大家分享Go语言在`1.18`引入的fuzzing模糊测试，其可以帮助我们快速发现Go代码里的漏洞或者可能导致程序崩溃的输入，废话不多说，我们开始吧。



## 为什么要有模糊测试

我们每个人写出来的代码都可能是有漏洞的，即使是一个最简单的功能都需要经过测试来验证，但是往往我们的测试是片面的，我们无法穷举出所有的测试用例，尤其在一些复杂的系统测试中，问题往往就隐藏在深处，而我们却无法感知，所以人们就在思考如何才能提前/快速发现代码中的漏洞呢？

模糊测试就是一种自动测试的方式，模糊器会向程序输入一系列的无效或随机的数据，这个测试尝试去造成程序崩溃、错误和内存泄漏等异常，模糊测试的思想是尝试找出代码的边界情况，用它来确保所有的数据输入、解析、存储和数据访问不会发生程序错误，达到防患于未然的作用。



## 怎么写模糊测试

`Go`语言在`1.18`引入了模糊测试，原生支持了模糊测试，就像 tests、benchmarks 和 race detection 一样，是 Go 的一等公民，我们以官网的例子来看一下怎么实现模糊测试；

假设现在我们实现一个字符串反转的功能，你可以写出这样一段代码：

```go
func Reverse(s string) string {
    b := []byte(s)
    for i, j := 0, len(b)-1; i < len(b)/2; i, j = i+1, j-1 {
        b[i], b[j] = b[j], b[i]
    }
    return string(b)
}
```

写好了以后我们肯定要写一个单元测试验证一番：

```go
func TestReverse(t *testing.T) {
	type args struct {
		s string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{"Hello, world", args{s: "Hello, world"}, "dlrow ,olleH"},
		{"test '' string",  args{s: ""}, ""},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Reverse(tt.args.s); got != tt.want {
				t.Errorf("Reverse() = %v, want %v", got, tt.want)
			}
		})
	}
}
```

运行结果：

```go
=== RUN   TestReverse
=== RUN   TestReverse/Hello,_world
=== RUN   TestReverse/test_''_string
--- PASS: TestReverse (0.00s)
    --- PASS: TestReverse/Hello,_world (0.00s)
    --- PASS: TestReverse/test_''_string (0.00s)
PASS

Process finished with the exit code 0
```

大家一看到测试通过了，好了可以转测了，结果第二天QA就提了一个`bug`单过了，备注`bug`原因：当输入中文字符串时，得到的结果不符合预期；

