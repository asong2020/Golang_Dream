## 前言

> 哈喽，大家好，我是`asong`。今天想与大家聊一聊如何用`Go`实现装饰器代码。为什么会有这个想法呢？最近由于项目需要一直在看`python`的代码，在这个项目中应用了大量的装饰器代码，一个装饰器代码可以在全文共用，减少了冗余代码。`python`的语法糖让实现装饰器变得很简单，但是`Go`语言的`糖`不多，而且又是强类型的静态无虚拟机的语言，所以，没有办法做到像` Java` 和 `Python` 那样写出优雅的装饰器的代码，但也是可以实现的，今天我们就看看如何`Go`语言写出装饰器代码！





## 什么是装饰器

介绍装饰器基本概念之前，我们先举个例子，跟装饰器很贴切：

> 如今我们的生活水平提高了，基本人手一台手机，大家也知道手机屏幕摔到地板上是很容易碎屏的，手机屏幕一坏，又要多花一笔费用进行维修，很是心痛；那么有什么什么办法来避免这个问题呢，在不破坏手机屏幕结构的情况下，让我们的手机更耐坏呢？其实我们只需要花几元钱买一个钢化膜，钢化膜在不改变原有手机屏幕的结构下，让手机变得更耐摔了。

根据上面这个例子，就可以引出本文的核心 -> 装饰器。装饰器本质就是：

> 函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。

装饰器是一个强大的功能，但是若想掌握，必须要理解闭包！闭包的概念我们在下面一小节说明，我们先来看一看`python`是如何使用装饰器的：

```go
def metric(fn):
    @functools.wraps(fn)
    def timer(*arag, **kw):
        start = time.time()
        num = fn(*arag, **kw)
        end = time.time()
        times = (end - start) * 1000
        print('%s executed in %s ms' % (fn.__name__, times))
        return num
    return timer

@metric
def Sum(x, y):
    time.sleep(0.0012)
    return x + y;


Sum(10, 20)
```

这里要实现功能很简单，`metric`就是一个装饰器函数，他可以作用于任何函数之上，并打印该函数的执行时间，有个这个装饰器，我们想要知道任何一个函数的执行时间，就简便很多了。

简单总结一下装饰器使用场景：

- 插入日志：使面向切面编程变的更简单了。
- 缓存：读写缓存使用装饰器来实现，减少了冗余代码。
- 事务处理：使代码看起来更简洁了。
- 权限校验：权限校验器是都是一套代码，减少了冗余代码。

装饰器的使用场景还用很多，就不一一列举了，下面我们就来看看如何使用`Go`也来实现装饰器代码吧！



## 闭包

装饰器的实现和闭包是分不开的，所以我们先来学习一下什么是闭包！

我们通常会把闭包和匿名函数弄混，这是因为：在 函数内部定义函数不常见，直到开始使用匿名函数才会这样做。而且， 只有涉及嵌套函数时才有闭包问题。因此，很多人是同时知道这两个概念的。

其实，闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是 它能访问定义体之外定义的非全局变量。

光看概念其实挺难理解闭包，我们通过例子来进行理解。

```go
func makeAverager() func(val float32) float32{
	series := make([]float32,0)
	return func(val float32) float32 {
		series = append(series, val)
		total := float32(0)
		for _,v:=range series{
			total +=v
		}
		return total/ float32(len(series))
	}
}

func main() {
	avg := makeAverager()
	fmt.Println(avg(10))
	fmt.Println(avg(30))
}
```

这个例子，你猜运行结果是什么？`10,30`还是`10,20`？

运行一下，答案出来了：`10,20`。为什么会这样呢？我们来分析一下！

上面的代码中`makeAverager`的写法在`C`语言中是不允许的，因为在`C`语言中，函数内的内存分配是在栈上的，在`makeAverager`返回后，这部分栈就被回收了，但是在`Go`语言中是没有问题的，因为`Go`语言会进行`escape analyze`分析出变量的作用范围，将变量在堆上进行内存分配，我们使用`go build --gcflags=-m ./test/test1.go `来看一下分析结果：

```go
# command-line-arguments
test/test1.go:21:13: inlining call to fmt.Println
test/test1.go:22:13: inlining call to fmt.Println
test/test1.go:8:2: moved to heap: series
test/test1.go:8:16: make([]float32, 0) escapes to heap
test/test1.go:9:9: func literal escapes to heap
test/test1.go:21:17: avg(10) escapes to heap
test/test1.go:21:13: []interface {} literal does not escape
test/test1.go:22:17: avg(30) escapes to heap
test/test1.go:22:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
```

从运行结果我们可以看出，`series`、`func`、`avg`都逃逸到了堆上。所以我们可以得出结论，`series`变量和`func(val float32) float32{}`被引用后，他所在的函数结束，也不会马上销毁，这也是变相延长了函数的生命周期！

小结：综上所诉，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定， 这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

**注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中 的外部变量。**



## Gin中装饰器的应用

大家应该都使用过`Gin`这个`Web`框架，其在注册路由时提供了中间件的使用，可以拦截**http请求-响应**生命周期的特殊函数，在请求-响应生命周期中可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。这个中间件其实就是使用的装饰器，我们来看一件简单的例子：

```go
func VerifyHeader() gin.HandlerFunc {
	return func(c *gin.Context) {
		header := c.Request.Header.Get("token")
		if header == "" {
			c.JSON(200, gin.H{
				"code":   1000,
				"msg":    "Not logged in",
			})
			return
		}
	}
}
func main()  {
	r := gin.Default()
	group := r.Group("/api/asong",VerifyHeader())
	{
		group.GET("/ping", func(context *gin.Context) {
			context.JSON(200,gin.H{
				"message": "pong",
			})
		})
	}
	r.Run()
}
```

这段代码很简单，我们只需要写一个`VerifyHeader`函数，在注册路由的时候添加进去就可以了，当有请求进来时，会先执行`gin.HanderFunc`函数，在`Gin`框架中使用一个切片来存储的，所以在添加中间件时，要注意添加顺序哦！

```go
// HandlerFunc defines the handler used by gin middleware as return value.
type HandlerFunc func(*Context)

// HandlersChain defines a HandlerFunc array.
type HandlersChain []HandlerFunc

func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain {
	finalSize := len(group.Handlers) + len(handlers)
	if finalSize >= int(abortIndex) {
		panic("too many handlers")
	}
	mergedHandlers := make(HandlersChain, finalSize)
	copy(mergedHandlers, group.Handlers)
	copy(mergedHandlers[len(group.Handlers):], handlers)
	return mergedHandlers
}
```



## net/http使用装饰器

上面我们看到了装饰器在`Gin`框架中的应用，这种设计大大减少了冗余代码的出现，也使代码的可扩展性提高了。那么接下来我们就在标准库`http`包上自己实现一个装饰器，练习一下。

我们知道`Go`语言的`http`标准库是不能使用中间件的，所以我们的机会来了，我们来给他实现一个！看代码：

```go
type DecoratorHandler func(http.HandlerFunc) http.HandlerFunc

func MiddlewareHandlerFunc(hp http.HandlerFunc, decors ...DecoratorHandler) http.HandlerFunc {
	for d := range decors {
		dp := decors[len(decors)-1-d]
		hp = dp(hp)
	}
	return hp
}

func VerifyHeader(h http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("token")
		if token == "" {
			fmt.Fprintf(w,r.URL.Path +" response: Not Logged in")
			return
		}
		h(w,r)
	}
}

func Pong(w http.ResponseWriter, r *http.Request)  {
	fmt.Fprintf(w,r.URL.Path +"response: pong")
	return
}


func main()  {
	http.HandleFunc("/api/asong/ping",MiddlewareHandlerFunc(Pong,VerifyHeader))
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
```

实现起来还是比较简单，这里重新声明了`DecoratorHandler`类型，本质就是`func(http.HandlerFunc) http.HandlerFunc`，这样更加方便我们添加中间件函数，中间件按照添加的顺序执行。



## 总结

好啦，本文到这里就结束了，这一文我们学习了闭包的概念，通过闭包我们学习了如何在`Go`语言中使用装饰器，因为`Go`语言中不支持注解这个语法糖，所以使用装饰器还是有点丑陋的，不过这个思想还是挺重要的，我们日常开发中可以参考这种思想，写出更优质的代码来！

**素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是`asong`，我们下期见。**

**创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。**

![](https://song-oss.oss-cn-beijing.aliyuncs.com/golang_dream/article/static/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E7%99%BD%E8%89%B2%E7%89%88.png)

推荐往期文章：

- [学习channel设计：从入门到放弃](https://mp.weixin.qq.com/s/E2XwSIXw1Si1EVSO1tMW7Q)
- [Go语言如何实现可重入锁？](https://mp.weixin.qq.com/s/S_EzyWZmFzzbBbxoSNe6Hw)
- [Go语言中new和make你使用哪个来分配内存？](https://mp.weixin.qq.com/s/xNdnVXxC5Ji2ApgbfpRaXQ)
- [源码剖析panic与recover，看不懂你打我好了！](https://mp.weixin.qq.com/s/yJ05a6pNxr_G72eiWTJ-rw)
- [空结构体引发的大型打脸现场](https://mp.weixin.qq.com/s/aHwGWWmnDFkcw2cyw5jmgw)
- [面试官：你能聊聊string和[]byte的转换吗？](https://mp.weixin.qq.com/s/jztwFH6thFdcySzowXOH_Q)
- [面试官：两个nil比较结果是什么？](https://mp.weixin.qq.com/s/CNOLLLRzHomjBnbZMnw0Gg)
- [面试官：你能用Go写段代码判断当前系统的存储方式吗?](https://mp.weixin.qq.com/s/DWMqzOi7wf79DoUUAJnr1w)
- [面试中如果这样写二分查找](https://mp.weixin.qq.com/s/z7NIzrcVRhpoLUQdFAa8JQ)